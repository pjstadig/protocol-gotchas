(ns protocol.gotchas
  (:require [protocol.cat :as cat]
            [protocol.dog :as dog]))

;; If you try to implement both protocols in the same defrecord, then you get a
;; compiler error, because you are actually implementing the Java interfaces
;; generated by each of the protocols, and you can only have one method with the
;; same name and argument types in a single class.
;;
;; (defrecord CatDog1 []
;;   cat/Cat
;;   (noise [this]
;;     (println "Meow!"))
;;   dog/Dog
;;   (noise [this]
;;     (println "Woof!")))
;;
;; => CompilerException java.lang.ClassFormatError: Duplicate method name&signature in class file records/core/CatDog1, compiling:(/Users/paul/src/records/src/records/core.clj:5:1)


;; You would have to implement the protocols this way to avoid the compiler
;; error, but in this case you now have a single implementation for both
;; protocols.  The advantage is that this will directly use Java's dispatch, so
;; it is about as fast as can be.
(defrecord CatDog1 []
  cat/Cat
  dog/Dog
  (noise [this]
    "err...woofeow?"))

;; protocol.gotchas> (cat/noise (CatDog1.))
;; "err...woofeow?"
;; protocol.gotchas> (dog/noise (CatDog1.))
;; "err...woofeow?"
;; protocol.gotchas> (contains? (ancestors CatDog1) protocol.cat.Cat)
;; true

;; If you extend the protocols separately, then you can have two different
;; implementations, but you do not get the Java dispatch performance.
(defrecord CatDog2 [])

(extend-type CatDog2
  cat/Cat
  (noise [this]
    "Meow!"))

(extend-type CatDog2
  dog/Dog
  (noise [this]
    "Woof!"))

;; protocol.gotchas> (cat/noise (CatDog2.))
;; "Meow!"
;; protocol.gotchas> (dog/noise (CatDog2.))
;; "Woof!"
;; protocol.gotchas> (contains? (ancestors CatDog2) protocol.cat.Cat)
;; false
